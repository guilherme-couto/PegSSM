\documentclass[manuscript, review, sigconf]{acmart}
\setcitestyle{super,sort&compress}
\citestyle{acmnumeric}
\usepackage{amsmath}

\usepackage{booktabs} % For formal tables
\usepackage{proof}
\usepackage{bussproofs}
\usepackage{url}
\usepackage[latin1]{inputenc}
\usepackage{lineno}
\usepackage[nounderscore]{syntax}
\setlength{\grammarparsep}{2pt}
\setlength{\grammarindent}{2em}

\usepackage{float}


\newcommand{\type}[1]{\emph{#1}}        % Type names in the text.
\newcommand{\rname}[1]{\textbf{\scriptsize \emph{#1}}} % Rule names in the type system.
\newcommand{\trname}[1]{\emph{\Small\textbf{#1}}} % Rule names in the text

%%% Number line on grammar environment
\makeatletter
\def\gr@implitem<#1> #2 {%
  \sbox\z@{\hskip\labelsep\grammarlabel{#1}{#2}}%
  \strut\@@@par% lineno.sty redefines \@@par which was in the original code
  \vspace{-\parskip}%
  \vspace{-\baselineskip}%
  \hrule\@height\z@\@depth\z@\relax%
  \item[\unhbox\z@]%
  \catcode`\<\active%
}
\makeatother



\floatstyle{ruled}
\restylefloat{figure}

\usepackage{listings}

\lstdefinestyle{uSugar}{
  emph={define, lambda, syntax, loop, if, true, false},
  emphstyle=\bf,
  basicstyle=\footnotesize, showspaces=false,
  firstnumber=auto, numbers=left, numbersep=1pt
}

\newcommand{\attr}{$\leftarrow$}
\newcommand{\zpp}[2]{\langle #1\bullet #2 \rangle}
\newcommand{\zppf}[2]{\langle #1\bullet #2 \rangle_{\bot}}

\newcommand{\q     }[1]{\mbox{\(\lbrack\!\lbrack{#1}\rbrack\!\rbrack \)}}


% Metadata Information
\acmConference[SBLP2021]{XXV BRAZILIAN SYMPOSIUM ON PROGRAMMING LANGUAGES}{September 23--27, 2021}{Brazil}

%\acmVolume{9}
%\acmNumber{4}
%\acmArticle{39}
%\acmYear{2010}
%\acmMonth{3}

%\acmBadgeL[http://ctuning.org/ae/ppopp2016.html]{ae-logo}
%\acmBadgeR[http://ctuning.org/ae/ppopp2016.html]{ae-logo}

% Copyright
\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

% DOI
\acmDOI{}

%\title{Toward a Modular Language Specification}
%\title{Toward Language-Independent Sugar Library Specification}
\title{Toward Language-Independent Sugar Libraries}

\author{ELTON M. CARDOSO}
\affiliation{%
  \institution{Universidade Federal de Ouro Preto}
  %\department{Departamento de Computa\c c\~ao e Sistemas}
  %\department{Departamento de Ci\^encia da Computa\c c\~ao}
  \city{Ouro Preto}
  \state{Minas Gerais}
  \country{Brazil}
}
\author{RODRIGO G. RIBEIRO}
\affiliation{%
  \institution{Universidade Federal de Ouro Preto}
  %\department{Departamento de Computa\c c\~ao e Sistemas}
  %\department{Departamento de Ci\^encia da Computa\c c\~ao}
  \city{Ouro Preto}
  \state{Minas Gerais}
  \country{Brazil}
}

\author{LEONARDO V. S. REIS}
%\orcid{1234-4564-1234-4565}
\affiliation{%
  \institution{Universidade Federal de Juiz de Fora}
  %\department{Departamento de Ci\^encia da Computa\c c\~ao}
  \city{Juiz de Fora}
  \state{Minas Gerais}
  \country{Brazil}
}
\email{lvsreis@ice.ufjf.br}

% Document starts
\begin{document}

\begin{abstract}

\end{abstract}

\keywords{PEG, parsing, semmantics}

\maketitle
\renewcommand{\shortauthors}{CARDOSO et al.}

\section{Introduction} \label{sec:intro}


\section{Definition fo the Parsing Grammar Expressions and the Abstract Machine} \label{sec:apeg}


The parsing expressions syntax is given by the grammar of the Figure~\ref{fig:grm-peg},as defined by \cite{Ford04}.

\begin{figure}[H]
  \begin{grammar} 
    <$e$> ::= $a$
    \alt $\epsilon$
    \alt $e\;e$
    \alt $e / e$
    \alt $e*$
    \alt $!e$
    \alt $v$
  \end{grammar}
 \caption{Grammar for Parsing Expression }
 \label{fig:grm-peg}
\end{figure}

The parsing expression grammar $G$ is a set of pairs $(V,e)$ whose $V$ is a varibale. The evaluation context for a PEG is defined by the grammar of the Figure~\ref{fig:grm-ctx}.

\begin{figure}[H]   
   \begin{grammar} 
     <$m$> ::= $a$
     \alt $\epsilon$
     \alt $\odot e$
     \alt $e \odot$
     \alt $\oslash e$
     \alt $e \oslash$
     \alt $\star$
     \alt $\neg$
   \end{grammar}
   \caption{Grammar for evaluation context }
   \label{fig:grm-ctx}
\end{figure}




The machine state is described by 5-upla $(G, e,\Gamma , \zpp{z}{w})$. where G is a Peg Grammar, $e$ is a peg expression, $\Gamma$ is an evaluation context, the  $\zpp{z}{w}$ is a zipper describing on the input string, where $z$ is the consumed portion of the input and $w$ is the reminder of the input. The empty input, represented by $\lambda$. Failed computations fail, the zipper will be subscripted, becoming a $\zppf{z}{w}$. 

The parsing expression $e$ will be preceded by a $\downarrow$, to indicate that the processing of that expression is to be started, or by an $\uparrow$ to indicate that the processing of that expression is to be finished. 

The $\Gamma$ context is managed as a stack, the empty contexto is written $[]$. A non-empty context is written $m : \Gamma$, where $m$ is a context expression.  

A PEG grammar $G$ is a set of pairs $(\mathcal{V},e)$ and denotes a rule $\mathcal{V} \leftarrow e$ onde $\mathcal{V}$ is a variable. For simplicity reasons it is assumed that there is only one varibale $\mathbb{V}$ in $G$.  

\section{Small step Semmantics} \label{sec:sem}

The semmantics relation has the form $(G, e,\Gamma ,z \bullet w) \rhd (G, e, \Gamma, \zpp{z'}{w'})$ where G is a Parsing Expression Grammars, $e$ is an expression, $\Gamma$ is a stack of $m$ expr , $z$ is the consumed input and $w$ is the input.


The rule \ref{r000} displayed in Figure \ref{fig:rule-eps} shows that when beginning processing the empty PEG, $\downarrow \epsilon$, the result is a state where the empty peg finished without consuming any input string. This rule always succeeds.   

\begin{figure}[H]
\begin{enumerate}
  \item \label{r000} $(G, \downarrow \epsilon,\Gamma ,\zpp{z}{w})       \rhd  (G, \uparrow \epsilon, \Gamma, \zpp{z}{w})$ 
\end{enumerate}
 \caption{Rules for a simple terminal}
 \label{fig:rule-eps}
\end{figure}

The rule \ref{r000} displayed in Figure \ref{fig:rule-eps} shows that when beginning processing the empty PEG, $\downarrow \epsilon$, the result is a state where the empty peg finished without consuming any input string. This rule always succeeds.  

\begin{figure}[H]
\begin{enumerate}\addtocounter{enumi}{1}
  \item \label{r010} $(G, \downarrow a,\Gamma ,\zpp{z}{aw})       \rhd  (G, \uparrow a, \Gamma, \zpp{za}{w})$ 
  \item \label{r020} $(G, \downarrow a,\Gamma ,\zpp{z}{bw})       \rhd  (G, \uparrow a, \Gamma, \zppf{z}{bw})$ 
  \item \label{r030} $(G, \downarrow a,\Gamma ,\zpp{z}{\lambda})  \rhd  (G, \uparrow a, \Gamma, \zppf{z}{\lambda})$ 
\end{enumerate}
 \caption{Rules for a simple terminal}
 \label{fig:rule-simple}
\end{figure}

Rules \ref{r040} to \ref{r080} determine the behavior on a sequence construction. Rule \ref{r040} states that the result of processing sequence $e_1e_2$  is 
to begin the processing of the subexpression $e_1$ inserting the expression $\odot e_2$ in the evaluation context. Rule 
\ref{r050} shows that in a state where  the processing of subexpression $e_1$ has ended and the expression $\odot e_2$ is on top of the 
evaluation stack the result is 

\begin{figure}[H]
\begin{enumerate}\addtocounter{enumi}{4}
  \item \label{r040} $(G, \downarrow e_1e_2,\Gamma ,\zpp{z}{w})    \rhd  (G, \downarrow e_1,  \odot e_2 : \Gamma, \zpp{z}{w})$ 
  \item \label{r050} $(G, \uparrow e_1 ,\odot e_2 : \Gamma ,\zpp{z}{w})   \rhd  (G, \downarrow e_2, e_1 \odot : \Gamma, \zpp{z}{w})$ 
  \item \label{r060} $(G, \uparrow e_2 ,e_1 \odot  : \Gamma ,\zpp{z}{w})   \rhd  (G, \uparrow e_1e_2, \Gamma, \zpp{z}{w})$
  \item \label{r070} $(G, \uparrow e_1 ,  \odot e_2 : \Gamma ,\zppf{z}{w})   \rhd  (G, \uparrow e_1 e_2, \Gamma, \zppf{z}{w})$ 
  \item \label{r080} $(G, \uparrow e_2 ,e_1 \odot  : \Gamma ,\zppf{z}{w})   \rhd  (G, \uparrow e_1e_2, \Gamma, \zppf{z}{w})$
\end{enumerate}
 \caption{Rules for seqeunce}
 \label{fig:rule-seq}
\end{figure}

\begin{figure}[H]
\begin{enumerate}\addtocounter{enumi}{9}
  \item \label{r090} $(G, \downarrow e_1 / e_2,\Gamma ,\zpp{z}{w})          \rhd  (G, \downarrow e_1,  \oslash e_2 : \Gamma, \zpp{z}{w})$ 
  \item \label{r100} $(G, \uparrow e_1 ,\oslash e_2 : \Gamma ,\zpp{z}{w})   \rhd  (G, \uparrow e_1 / e_2 , \Gamma, \zpp{z}{w})$ 
  \item \label{r110} $\dfrac{(G, \uparrow e_1 ,e_2 \oslash  : \Gamma ,\zppf{z'}{w'})}{(G, \uparrow e_1 ,e_2 \oslash  : \Gamma ,\zppf{z}{w}) \rhd  (G, \downarrow e_2 , e1 \oslash : \Gamma, \zpp{z}{w})}$
  \item \label{r120} $(G, \uparrow e_2 ,e_1 \oslash  : \Gamma ,\zpp{z}{w})  \rhd  (G, \uparrow e_1 / e_2, \Gamma, \zpp{z}{w})$ 
  \item \label{r130} $(G, \uparrow e_2 ,e_1 \oslash  : \Gamma ,\zppf{z}{w}) \rhd  (G, \uparrow e_1 / e_2, \Gamma, \zppf{z}{w})$
\end{enumerate}
 \caption{Rules for alternative}
 \label{fig:rule-seq}
\end{figure}



\begin{figure}[H]
\begin{enumerate}\addtocounter{enumi}{9}
  \item \label{r090} $(G, \downarrow ! e,\Gamma ,\zpp{z}{w})       \rhd  (G, \downarrow e, \neg : \Gamma, \zppf{z}{w})$ 
  \item \label{r100} $(G, \uparrow e , \neg : \Gamma ,\zppf{z}{w}) \rhd  (G, \uparrow !e,  \Gamma, \zpp{z}{w})$ 
 
\end{enumerate}
 \caption{Rules for not}
 \label{fig:rule-seq}
\end{figure}



\begin{figure}[H]
\begin{enumerate}\addtocounter{enumi}{9}
  \item \label{r090} $(G, \downarrow e_1e_2,\Gamma ,\zpp{z}{w})    \rhd  (G, \downarrow e_1,  \odot e_2 : \Gamma, \zpp{z}{w})$ 
  \item \label{r100} $(G, \uparrow e_1 ,\odot e_2 : \Gamma ,\zpp{z}{w})   \rhd  (G, \downarrow e_2, e_1 \odot : \Gamma, \zpp{z}{w})$ 
  \item \label{r110} $(G, \uparrow e_2 ,e_1 \odot  : \Gamma ,\zpp{z}{w})   \rhd  (G, \uparrow e_1e_2, \Gamma, \zpp{z}{w})$
  \item \label{r120} $(G, \uparrow e_1 ,  \odot e_2 : \Gamma ,\zppf{z}{w})   \rhd  (G, \uparrow e_1 e_2, \Gamma, \zppf{z}{w})$ 
  \item \label{r130} $(G, \uparrow e_2 ,e_1 \odot  : \Gamma ,\zppf{z}{w})   \rhd  (G, \uparrow e_1e_2, \Gamma, \zppf{z}{w})$
\end{enumerate}
 \caption{Rules for klenee}
 \label{fig:rule-seq}
\end{figure}


\[
\begin{array}{lcl} 
 (G, \downarrow \epsilon,\Gamma ,z \bullet w) & \rhd & (G, \uparrow \epsilon, \Gamma, z \bullet w) \\
 (G, \downarrow e1/e2, \Gamma ,z \bullet w)   & \rhd & (G, \uparrow e1, \otimes e2 : \Gamma, z \bullet w) \\
\end{array}
\]

\section{Haskell implementation}

\section{Related Work} \label{sec:related}


\section{Conclusions} \label{sec:conc}


\begin{acks}
This work is supported by the \grantsponsor{CNPq}{CNPq -- Brazil}{} under grant No.: \grantnum{CNPq}{426232/2016}.
\end{acks}


\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
